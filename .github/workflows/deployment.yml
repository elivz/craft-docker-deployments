name: Deploy

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      domain:
        required: true
        type: string
      basic-auth:
        type: string
      health-check-path:
        type: string
        default: '/actions/app/health-check'
        description: 'Health check endpoint path'

env:
  GHCR_REGISTRY: ghcr.io
  GHCR_REPOSITORY: ${{ github.repository }}/web

jobs:
  # Job 1: Build and push Docker images
  build:
    name: Build and Push Images
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.DEPLOY_HOST }}" ] || [ -z "${{ secrets.DEPLOY_USER }}" ] || [ -z "${{ secrets.DEPLOY_KEY }}" ]; then
            echo "Error: Missing required deployment secrets (DEPLOY_HOST, DEPLOY_USER, DEPLOY_KEY)"
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create .env file
        run: touch .env

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push images
        id: build
        uses: docker/bake-action@v6
        with:
          files: docker-compose.ci.yml
          push: true
          set: |
            *.cache-from=type=registry,ref=${{ env.GHCR_REGISTRY }}/${{ env.GHCR_REPOSITORY }}:latest
            *.cache-from=type=gha,scope=cached-stage
            *.cache-to=type=gha,scope=cached-stage,mode=max
        env:
          BRANCH: ${{ inputs.environment }}

  # Job 2: Deploy containers and verify health
  deploy-and-verify:
    name: Deploy and Verify
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ inputs.environment }}
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy Docker configuration
        uses: easingthemes/ssh-deploy@main
        with:
          REMOTE_HOST: ${{ secrets.DEPLOY_HOST }}
          REMOTE_USER: ${{ secrets.DEPLOY_USER }}
          SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_KEY }}
          ARGS: "-rltgoDzvO"
          SOURCE: "docker-compose.deployment.yml"
          TARGET: "${{ inputs.environment }}/docker-compose.yml"

      - name: Deploy containers with blue-green strategy
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        continue-on-error: true
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_KEY }}
          command_timeout: 5m
          script: |
            set -e
            source ~/.bashrc
            
            # Setup environment
            mkdir -p ${{ inputs.environment }}
            cd ${{ inputs.environment }}
            
            # Login to registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login --username ${{ github.actor }} --password-stdin ${{ env.GHCR_REGISTRY }}
            
            # Configure docker-compose file
            sed -i -e "s|{BRANCH}|${{ inputs.environment }}|g" docker-compose.yml
            sed -i -e "s|{VIRTUAL_HOST}|${{ inputs.domain }}|g" docker-compose.yml
            sed -i -e "s|{GHCR_REGISTRY}|${{ env.GHCR_REGISTRY }}|g" docker-compose.yml
            sed -i -e "s|{GHCR_REPOSITORY}|${{ env.GHCR_REPOSITORY }}|g" docker-compose.yml
            
            echo "üöÄ Starting zero-downtime deployment..."
            
            # Pull new images
            echo "üì• Pulling new images..."
            docker compose pull -q
            
            # Start new containers alongside existing production
            # Both will have the same VIRTUAL_HOST, so nginx-proxy will load balance
            echo "üî¨ Starting new containers alongside current production..."
            docker compose --profile deployment up --detach --wait --no-build web-new queue-new --scale web-new=1 --scale queue-new=1
            
            echo "‚è≥ Waiting for new services to be ready..."
            sleep 15
            
            # Verify new services are running and healthy
            WEB_NEW_RUNNING=$(docker compose ps --services --filter "status=running" | grep "web-new" | wc -l)
            if [ "$WEB_NEW_RUNNING" -eq 0 ]; then
              echo "‚ùå New web service failed to start"
              exit 1
            fi
            
            # Verify nginx-proxy can reach new container
            echo "üîç Verifying nginx-proxy can reach new container..."
            for i in {1..6}; do
              if docker compose exec -T web-new curl -sf http://localhost:8080/actions/app/health-check > /dev/null; then
                echo "‚úÖ New container health check passed (attempt $i)"
                break
              else
                echo "‚è≥ New container not ready yet (attempt $i/6)..."
                if [ $i -eq 6 ]; then
                  echo "‚ùå New container failed health check after 6 attempts"
                  exit 1
                fi
                sleep 5
              fi
            done
            
            echo "‚úÖ New services are running and healthy"
            echo "üåê nginx-proxy is now load balancing between old and new containers"

      - name: Health Check
        id: health-check
        if: steps.deploy.outcome == 'success'
        uses: jtalk/url-health-check-action@v4
        with:
          url: https://${{ inputs.domain }}${{ inputs.health-check-path }}
          max-attempts: 6
          retry-delay: 5s
          basic-auth: ${{ inputs.basic-auth }}

      - name: Complete zero-downtime deployment
        id: complete-deployment
        if: steps.deploy.outcome == 'success' && steps.health-check.outcome == 'success'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_KEY }}
          command_timeout: 3m
          script: |
            set -e
            source ~/.bashrc
            cd ${{ inputs.environment }}
            
            echo "üîÑ Completing zero-downtime deployment..."
            
            # At this point both web and web-new containers are running
            # and nginx-proxy is load balancing between them
            echo "üåê Both old and new containers are serving traffic"
            
            # Wait a bit to ensure new container is stable under load
            echo "‚è≥ Monitoring new container stability..."
            sleep 30
            
            # Verify new container is still healthy before proceeding
            if ! docker compose exec -T web-new curl -sf http://localhost:8080/actions/app/health-check > /dev/null; then
              echo "‚ùå New container became unhealthy, aborting deployment"
              exit 1
            fi
            
            # Now gracefully remove the old container
            # nginx-proxy will automatically route all traffic to web-new
            echo "‚èπÔ∏è Gracefully stopping old production containers..."
            docker compose stop web queue
            
            # Wait for graceful shutdown and connection draining
            sleep 10
            
            # Remove old containers
            echo "üßπ Removing old production containers..."
            docker compose rm -f web queue
            
            # Now promote web-new to web by recreating the production services
            echo "üîÑ Promoting new containers to production names..."
            
            # Start fresh production containers with the new image FIRST
            # This ensures nginx-proxy always has containers to route to
            echo "üöÄ Starting fresh production containers alongside -new containers..."
            docker compose up --detach --no-build web queue --wait
            
            # Give nginx-proxy time to detect the new production containers
            echo "‚è≥ Allowing nginx-proxy to detect new production containers..."
            sleep 15
            
            # Verify the final web container is healthy before cleaning up
            echo "üîç Verifying final production container health..."
            for i in {1..6}; do
              if docker compose exec -T web curl -sf http://localhost:8080/actions/app/health-check > /dev/null; then
                echo "‚úÖ Final production container health check passed (attempt $i)"
                break
              else
                echo "‚è≥ Final production container not ready yet (attempt $i/6)..."
                if [ $i -eq 6 ]; then
                  echo "‚ùå Final production container failed health check, keeping -new containers as backup"
                  exit 1
                fi
                sleep 5
              fi
            done
            
            # NOW we can safely stop the -new containers
            # nginx-proxy will route all traffic to the fresh 'web' and 'queue' containers
            echo "‚èπÔ∏è Stopping temporary -new containers..."
            docker compose --profile deployment stop web-new queue-new
            
            # Clean up the -new containers
            echo "üßπ Cleaning up temporary -new containers..."
            docker compose --profile deployment rm -f web-new queue-new
            
            echo "‚úÖ Zero-downtime deployment completed successfully!"
            echo "üéØ Active container: web (with new code)"

      - name: Rollback on failure
        if: always() && (steps.deploy.outcome == 'failure' || steps.health-check.outcome == 'failure')
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_KEY }}
          command_timeout: 120s
          script: |
            set -e
            source ~/.bashrc
            cd ${{ inputs.environment }}
            
            echo "üö® Deployment or health check failed, performing rollback..."
            
            # Stop and remove failed new containers
            echo "‚èπÔ∏è Stopping failed new containers..."
            docker compose --profile deployment stop web-new queue-new || true
            docker compose --profile deployment rm -f web-new queue-new || true
            
            # Verify production containers are still running and healthy
            echo "üîç Verifying production containers are still running and healthy..."
            WEB_RUNNING=$(docker compose ps --services --filter "status=running" | grep -E "^web$" | wc -l)
            QUEUE_RUNNING=$(docker compose ps --services --filter "status=running" | grep -E "^queue$" | wc -l)
            
            if [ "$WEB_RUNNING" -eq 0 ]; then
              echo "üîÑ Production web container not running, restarting..."
              docker compose up --detach --no-build web redis --wait
              
              # Verify web container is healthy after restart
              for i in {1..6}; do
                if docker compose exec -T web curl -sf http://localhost:8080/actions/app/health-check > /dev/null; then
                  echo "‚úÖ Production web container restarted and healthy (attempt $i)"
                  break
                else
                  echo "‚è≥ Production web container not ready yet (attempt $i/6)..."
                  if [ $i -eq 6 ]; then
                    echo "‚ùå Production web container failed to restart properly"
                    exit 1
                  fi
                  sleep 5
                fi
              done
            else
              echo "‚úÖ Production web container is running"
              # Still verify it's healthy
              if docker compose exec -T web curl -sf http://localhost:8080/actions/app/health-check > /dev/null; then
                echo "‚úÖ Production web container is healthy"
              else
                echo "‚ö†Ô∏è Production web container is running but failing health checks"
              fi
            fi
            
            if [ "$QUEUE_RUNNING" -eq 0 ]; then
              echo "üîÑ Production queue container not running, restarting..."
              docker compose up --detach --no-build queue --wait
            else
              echo "‚úÖ Production queue container is running"
            fi
            
            echo "‚úÖ Rollback completed - production containers are active and healthy"

      - name: Mark deployment as failed
        if: steps.deploy.outcome == 'failure' || steps.health-check.outcome == 'failure'
        run: |
          echo "::error::Deployment failed and rollback was attempted"
          exit 1
          

  # Job 3: Clean up old images
  cleanup-images:
    name: Cleanup old images
    runs-on: ubuntu-latest
    needs: deploy-and-verify
    steps:
      - name: Remove old untagged images
        uses: actions/delete-package-versions@v5
        with:
          package-name: "${{ github.event.repository.name }}/web"
          package-type: 'container'
          min-versions-to-keep: 10
          ignore-versions: '^[a-zA-Z-]+$'

  # Job 3: Run database migrations and clear caches
  migrate:
    name: Run Migrations
    runs-on: ubuntu-latest
    needs: deploy-and-verify
    environment: ${{ inputs.environment }}
    timeout-minutes: 30
    steps:
      - name: Run Craft migrations and clear caches
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_KEY }}
          command_timeout: 25m
          script: |
            set -e
            source ~/.bashrc
            cd ${{ inputs.environment }}
            
            # Verify the active web container is running
            WEB_RUNNING=$(docker compose ps --services --filter "status=running" | grep -E "^web$" | wc -l)
            
            if [ "$WEB_RUNNING" -eq 0 ]; then
              echo "‚ùå Active web container not found or not running"
              exit 1
            fi
            
            echo "üóÉÔ∏è Running migrations on active web container..."
            docker compose exec -T web php craft up --interactive=0
            
            echo "üßπ Clearing caches..."
            docker compose exec -T web php craft clear-caches/compiled-classes --interactive=0
            docker compose exec -T web php craft clear-caches/compiled-templates --interactive=0
            docker compose exec -T web php craft invalidate-tags/all --interactive=0
            
            echo "‚úÖ Migrations and cache clearing completed"
